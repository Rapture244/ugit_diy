# ==================================================================================================================== #
#                                                BUILD SYSTEM (PEP 517/518)                                            #
# ==================================================================================================================== #
# Modern minimal backend. Works great with PEP 621 metadata + uv.
[build-system]
requires = ["hatchling >= 1.26"]
build-backend = "hatchling.build"


# ==================================================================================================================== #
#                                                    PROJECT METADATA (PEP 621)                                        #
# ==================================================================================================================== #
# Core, declarative metadata used by build tools and indexes (wheel/sdist).
[project]
name = "ugit-diy"   # The distribution name on PyPI aka the public package name for installers, not the import name
dynamic = ["version"]
description = "A DIY Python implementation of a simple Git-like version control system."
readme = "README.md"

authors = [
    { name = "ovidiu.pascal", email = "ovidiu.pascal@orange.com" }
]

# License information (preferred: a LICENSE file at project root)
license = { file = "LICENSE" }

# Minimum supported Python version for this project
requires-python = ">=3.12"

# Keep runtime deps lean; notebooks & tooling go to dev groups/extras (not embedded in wheels/sdists).
dependencies = []

# Keywords help with discoverability on PyPI
keywords = ["git", "vcs", "learning", "cli", "python"]

# Trove classifiers (used by PyPI and tooling)
classifiers = [
  "Development Status :: 3 - Alpha",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3.12",
  "License :: OSI Approved :: MIT License",
  "Operating System :: POSIX :: Linux"
]

# Helpful links (repository, homepage, issue tracker, etc.)
[project.urls]
Homepage = "https://github.com/username/ugit-diy-python"
Repository = "https://github.com/username/ugit-diy-python.git"
Issues = "https://github.com/username/ugit-diy-python/issues"

# ==================================================================================================================== #
#                                               CLI ENTRY POINTS (SCRIPTS)                                             #
# ==================================================================================================================== #
# Optional CLI command(s) exposed when the project is installed.
# Creates a wrapper script in .venv/bin (Linux/Mac) or .venv/Scripts (Windows).
# Example: after install, run 'ugit' instead of 'python -m ugit_diy.cli.main'
[project.scripts]
ugit = "ugit_diy.cli:main"

# ==================================================================================================================== #
#                           DEV & DOCS DEPENDENCIES — uv Groups vs pip/poetry Extras                                   #
# ==================================================================================================================== #
# (PEP 735) [dependency-groups] — uv-only, LOCAL-ONLY dev groups (never included in wheels/sdists).
# Use when DEVELOPING with uv:
#   uv sync --group dev
#   uv sync --group docs
[dependency-groups]
dev = [
  "pre-commit>=4.3.0",
  "pyright>=1.1.404",
  "ruff>=0.12.10",
]
docs = [
  "mkdocs>=1.6",
  "mkdocs-material>=9"
]

# (PEP 621) [project.optional-dependencies] — EXTRAS published in package metadata (visible to pip/poetry/hatch).
# Use when INSTALLING with classic tools:
#   pip install .[dev]
#   pip install .[docs]
#
# NOTE: Extras MUST be explicit lists. They CANNOT alias uv groups.
#       (Your previous attempt failed because TOML here expects an array of strings, not a table.)
[project.optional-dependencies]
#dev = ["pyright>=1.1.404", "ruff>=0.12.10"]
#docs = ["mkdocs>=1.6", "mkdocs-material>=9"]




# ==================================================================================================================== #
#                                            HATCH: EXPLICIT SRC PACKAGE DISCOVERY                                     #
# ==================================================================================================================== #
[tool.hatch.version]
path = "src/ugit_diy/__init__.py"

# Tell Hatchling where to find your package (src/ layout) and ship the typing marker.
[tool.hatch.build.targets.wheel]
packages = ["src/ugit_diy"]           # Point directly at the src path (string form avoids dict/table parsing issues).
include = [
  "src/ugit_diy/py.typed"
]

# Source distribution: include everything needed to rebuild project from source.
[tool.hatch.build.targets.sdist]
include = [
  "src/ugit_diy/**",
  "src/ugit_diy/py.typed",
  "README.md",
  "LICENSE",
  "pyproject.toml"
]

# ==================================================================================================================== #
#                                                         RUFF                                                         #
# ==================================================================================================================== #
# Linter + formatter config in one place to avoid ruff.toml drift
[tool.ruff]
exclude = [
  ".idea",
  ".vscode",
  ".git",
  ".venv",
  "__pycache__",
  ".ipynb_checkpoints",
  "build",
  "dist",
  "node_modules",
  "htmlcov"
]
line-length = 120
indent-width = 4
target-version = "py312"

# --- File discovery / execution --- #
force-exclude = true        # Always respect [tool.ruff].exclude, even if you pass paths explicitly (saves surprises)
cache-dir = ".ruff_cache"   # Store Ruff’s cache in a predictable folder; easy to .gitignore or cache in CI

# --- Fixing behavior --- #
fix = false                 # Default to check-only. Ruff will fix issues ONLY when you explicitly run with --fix

# ----------------------------------------------- LINTER (rules & behavior) ------------------------------------------- #
[tool.ruff.lint]
# Rule families included in linting:
# - E/W   : PEP8 style & whitespace rules (pycodestyle)
# - F     : Logic errors (undefined names, unused vars/imports) (pyflakes)
# - I     : Import sorting & cleanup (isort)
# - UP    : Modern Python syntax upgrades (pyupgrade)
# - B     : Bug and anti-pattern detection (flake8-bugbear)
# - COM   : Comma rules (trailing/missing commas, except COM812 left to formatter)
# - ISC   : Implicit string concatenation (avoid subtle bugs)
# - ICN   : Import naming conventions
# - PGH   : Pragma hygiene (valid / unnecessary `# noqa` and ignores)
# - RUF   : Ruff-specific best practices
# - D     : Docstring rules (pydocstyle, enforcing Google convention)
# - N     : Naming conventions (PEP8: ClassName, function_name, CONSTANT_CASE, etc.)
# - ARG   : Detect unused function arguments
# - SIM   : Simplify overly complex code (suggest cleaner idioms)
# - RET   : Ensure functions return consistently (all paths return or none do)
# - S     : Security checks (subset of Bandit rules, e.g. unsafe `eval`)
# - G     : Logging best practices (e.g. prefer lazy logging with `%s` or f-string)
# - T20   : Debug artifacts (e.g. `print`, `pdb` calls)
# - BLE   : Broad/bare excepts (catching `Exception` or no exception type)
# - PT    : Pytest best practices (parametrize, fixtures, etc.)
# - TCH   : Type-checking imports (organize imports inside `if TYPE_CHECKING`)
# - A     : Prevent shadowing Python builtins (don’t redefine `list`, `dict`, etc.)
# - DTZ   : Datetime usage (require timezone-aware datetimes)

select = [
  "E", "W", "F", "I", "UP", "B", "COM", "ISC", "ICN", "PGH", "RUF", "D",
  "N", "ARG", "SIM", "RET", "S", "G", "T20", "BLE", "PT", "TCH", "A", "DTZ"
]

# Let the formatter handle wrapping and trailing commas
ignore = [
  "E501",   # line too long -> formatter decides
  "COM812"  # missing trailing comma -> formatter decides
]

# Auto-fix where safe
# Allow only mechanical, semantics-preserving fixes:
# - I: import sorting
# - UP: modern syntax upgrades
# - E/W: pycodestyle whitespace/indent/cosmetic fixes
# - COM: comma/whitespace tweaks
# - F401/F841: remove truly unused imports/variables
fixable = ["I", "UP", "E", "W", "COM", "F401", "F841"]

# Block categories that could change behavior or intent:
# - B: bugbear (some fixes delete/reshape logic)
# - ISC: implicit string concat rewrites
# - ICN: import-convention renames (can break APIs/expectations)
# - PGH: pragma hygiene (can drop ignores you rely on)
# - RUF015: list(...)[0] -> next(iter(...)) changes exception semantics
unfixable = ["B", "ISC", "ICN", "PGH", "RUF015"]

# Treat underscore / unused_* as intentionally unused
dummy-variable-rgx = "^(_|unused_).*"

# ----------------------------------------------- LINTER: FAMILY CONFIGS --------------------------------------------- #
# Docstrings: enforce Google-style across public API.
[tool.ruff.lint.pydocstyle]
convention = "google"

# Import sorting: make Ruff aware of src/ layout and your package.
[tool.ruff.lint.isort]
known-first-party = ["ugit_diy"]
src-paths = ["src"]
combine-as-imports = true
force-sort-within-sections = true

# Pytest style: enforce consistent fixture and parametrize syntax.
[tool.ruff.lint.pytest]
fixture-parentheses = true           # Use @pytest.fixture() (with parens), even when no args are passed
parametrize-names-type = "tuple"     # Prefer tuple style: @pytest.mark.parametrize(("a","b"), [...])

# Import hygiene: prefer explicit absolute imports (ban relative "from .x import y").
[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"         # Options: "all" | "parents" | "none"

# Builtins safety: don’t redefine Python builtins (list, dict, id, type, etc.).
[tool.ruff.lint.flake8-builtins]
builtins-ignorelist = []             # Add exceptions here only if absolutely necessary

# Per-file ignores: keep minimal; add more only when noise appears.
[tool.ruff.lint.per-file-ignores]
"tests/**" = ["F841"]       # allow unused vars in tests
"docs/**/*.py" = ["E402"]   # allow "import not at top" in docs
"**/__init__.py" = ["F401"] # allow re-export patterns

# ------------------------------------------------- FORMATTER (code style) ------------------------------------------- #
[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "lf"
docstring-code-format = false             # Format code blocks inside docstrings as if they were Python
docstring-code-line-length = "dynamic"

# ==================================================================================================================== #
#                                                       PYRIGHT                                                        #
# ==================================================================================================================== #
# NOTE: We are using a SOURCE LAYOUT. Configure Pyright to resolve imports via 'src'.
# NOTE: If pyrightconfig.jsonc also exists, it takes precedence over this table.

[tool.pyright]
# --- Environment / interpreter selection ---
venvPath = "."              # Let Pyright locate your local venv in project root
venv = ".venv"

# Target versions/platform (WSL/UNIX)
pythonVersion = "3.12"
pythonPlatform = "Linux"

# --- Project layout ---
# Analyze what we own: src and tests. Use explicit roots for clarity and speed.
include = ["src", "tests"]
exclude = [
  ".idea",
  ".vscode",
  ".venv",
  ".git",
  "**/__pycache__",
  ".mypy_cache",
  ".pytest_cache",
  "build",
  "dist",
  "htmlcov",
  "node_modules",
  "**/.ipynb_checkpoints"
]

# Use library code when stubs are missing (more practical in strict mode)
useLibraryCodeForTypes = true

# --- Strictness baseline ---
typeCheckingMode = "strict"
reportMissingTypeStubs = "warning"              # Downgrade missing stubs (too noisy otherwise)
reportMissingImports = "error"                  # Missing imports stay hard errors
reportUnnecessaryTypeIgnoreComment = "error"    # Clean up stale ignores
reportImplicitStringConcatenation = "error"     # Catch silent bugs with multiline strings
reportPrivateUsage = "error"                    # Prevent leaking internal APIs

# --- Additional diagnostics (strict but practical) ---
# Encourage full typing without blocking iteration
reportUnknownVariableType = "warning"
reportUnknownParameterType = "warning"
reportUnknownArgumentType = "warning"
reportUnknownMemberType = "warning"
reportUntypedFunctionDecorator = "warning"

# Correctness hard errors
reportMissingTypeArgument = "error"
reportIncompatibleVariableOverride = "error"

# Hygiene / cleanup
reportUnusedImport = "warning"
reportUnusedVariable = "warning"
reportUnreachable = "warning"

# Optional but handy if you add custom stubs later
stubPath = "typings"

# CLI noise toggle; enable when debugging import resolution
verboseOutput = false

# --- Execution environments (robust for SRC layout) ---
executionEnvironments = [
  # Default project root: imports like "import ugit_diy" resolve to src/
  { root = ".", extraPaths = ["src"], pythonVersion = "3.12", pythonPlatform = "Linux" },

  # Test root: opening tests/ in editor still resolves to src/
  { root = "tests", extraPaths = ["src"], pythonVersion = "3.12", pythonPlatform = "Linux" }
]

# ==================================================================================================================== #
#                                                     COVERAGE.PY                                                      #
# ==================================================================================================================== #
# Measures how much of your code executes during tests. Branch coverage is stricter than line coverage.
# Only measure the package (not tests or deps). Fail CI if total coverage < 85%. Show missing lines; hide fully covered files.
[tool.coverage.run]
branch = true
source = ["ugit_diy"]

[tool.coverage.report]
fail_under = 85
show_missing = true
skip_covered = true
